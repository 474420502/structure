<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# hashmap

```go
import "github.com/474420502/structure/map/hashmap"
```

## Index

- [type HashMap](<#type-hashmap>)
  - [func New() *HashMap](<#func-new>)
  - [func NewWithCap(cap int) *HashMap](<#func-newwithcap>)
  - [func (hm *HashMap) Clear()](<#func-hashmap-clear>)
  - [func (hm *HashMap) Empty() bool](<#func-hashmap-empty>)
  - [func (hm *HashMap) Get(key interface{}) (value interface{}, isfound bool)](<#func-hashmap-get>)
  - [func (hm *HashMap) Keys() []interface{}](<#func-hashmap-keys>)
  - [func (hm *HashMap) Put(key interface{}, value interface{}) bool](<#func-hashmap-put>)
  - [func (hm *HashMap) Remove(key interface{})](<#func-hashmap-remove>)
  - [func (hm *HashMap) Set(key interface{}, value interface{})](<#func-hashmap-set>)
  - [func (hm *HashMap) Size() int](<#func-hashmap-size>)
  - [func (hm *HashMap) Slices() []Slice](<#func-hashmap-slices>)
  - [func (hm *HashMap) String() string](<#func-hashmap-string>)
  - [func (hm *HashMap) Values() []interface{}](<#func-hashmap-values>)
- [type Slice](<#type-slice>)
- [examples](<#examples>)


## type [HashMap](<#examples>)

HashMap map base on hash

```go
type HashMap struct {
    // contains filtered or unexported fields
}
```

## type [Slice](<#examples>)

Slice the KeyValue

```go
type Slice struct {
    Key, Value interface{}
}
```

### func [New](<#examples>)

```go
func New() *HashMap
```

New instantiates a hash map\.

### func [NewWithCap](<#examples>)

```go
func NewWithCap(cap int) *HashMap
```

New instantiates a hash map with  Capacity\.

### func \(\*HashMap\) [Clear](<#examples>)

```go
func (hm *HashMap) Clear()
```

Clear clear the hashmap

### func \(\*HashMap\) [Empty](<#examples>)

```go
func (hm *HashMap) Empty() bool
```

Empty if the hashmap is empty\, return true

### func \(\*HashMap\) [Get](<#examples>)

```go
func (hm *HashMap) Get(key interface{}) (value interface{}, isfound bool)
```

Get get the element by key

### func \(\*HashMap\) [Keys](<#examples>)

```go
func (hm *HashMap) Keys() []interface{}
```

Keys return the all keys of hashmap\. non order

### func \(\*HashMap\) [Put](<#examples>)

```go
func (hm *HashMap) Put(key interface{}, value interface{}) bool
```

Put inserts element into the map With Not Cover\. if key exists return false\. else return true

### func \(\*HashMap\) [Remove](<#examples>)

```go
func (hm *HashMap) Remove(key interface{})
```

Remove remove the element by key

### func \(\*HashMap\) [Set](<#examples>)

```go
func (hm *HashMap) Set(key interface{}, value interface{})
```

Set inserts element into the map With Set\.

### func \(\*HashMap\) [Size](<#examples>)

```go
func (hm *HashMap) Size() int
```

Size return the size of hashmap

### func \(\*HashMap\) [Slices](<#examples>)

```go
func (hm *HashMap) Slices() []Slice
```

Slices return the all keyvalue of hashmap\. non order

### func \(\*HashMap\) [String](<#examples>)

```go
func (hm *HashMap) String() string
```

String print the hashmap

### func \(\*HashMap\) [Values](<#examples>)

```go
func (hm *HashMap) Values() []interface{}
```

Values return the all values of hashmap\. non order


## examples

```go
package main

import (
	"log"

	"github.com/474420502/structure/map/hashmap"
)

func main() {

	hm := hashmap.New()

	log.Println("Put Set Get String")
	log.Println(hm.Put(1, 1))       // true
	log.Println(hm.Put(1, 1))       // false
	log.Println(hm.Put('a', 2))     // true
	log.Println(hm.Put("apple", 4)) // true
	hm.Set("apple", 3)
	log.Println(hm.String()) // map[1:1 97:2 apple:3]

	log.Println(hm.Get(1))       // 1 true
	log.Println(hm.Get(2))       // <nil> false
	log.Println(hm.Get('a'))     // 2 true
	log.Println(hm.Get("apple")) // 3 true

	log.Println("Keys Values Slices")
	log.Println(hm.Keys())   // [1 'a'(97) apple]
	log.Println(hm.Values()) // [1 2 3]
	log.Println(hm.Slices()) // [{1 1} {97 2} {apple 3}]

	log.Println("Size Remove")
	log.Println(hm.Size())
	hm.Remove(1)
	log.Println(hm.String()) // map[97:2 apple:3]
	hm.Remove('a')
	log.Println(hm.String()) // map[apple:3]
	hm.Remove(2)
	log.Println(hm.String()) // map[apple:3]

	log.Println("Clear Empty")
	hm.Clear()
	log.Println(hm.Empty())  // true
	log.Println(hm.String()) // map[]
}

```


 